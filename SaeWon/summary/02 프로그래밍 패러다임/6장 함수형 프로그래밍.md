# 6장. 함수형 프로그래밍

## 서론

알론소 처치 → 람다계산법

## 정수를 제곱하기

range가 x로 할당되는것

take에서 끝이없는 정수가 평가되어 계산

range vs i 

불변, 가변

## 불변성과 아키텍처

가변성의 문제 : 동시성이슈에서 발생 

업데이트의 문제가 없기 때문에 교착상태가 일어나지 않음. 

모두 불변하게 설계하는게 가능? : 자원의 한계, 타협이 필요

## 타협지점

### 가변성의 분리

불변컴포넌트 

→ 함수형방식으로만 작업처리

→ 하나 이상의 가변컴포넌트와 서로 통신

트랜잭션 메모리 같은 실천법을 통해 가변변수를 보호

불변, 가변컴포넌트를 분리해야한다.

가급적이면 많은 처리를 불변 컴포넌트로 옮겨야 한다. 

## 이벤트 소싱

잔고 변경 x → 트랜잭션 자체를 저장 

이벤트소싱: 상태가 아닌 트랜잭션을 저장하자

데이터 저장소가 크게 필요함. 

삭제되거나 변경되는 것이 하나도 없음. 

CR만 수행 UD수행하지 않음. 

## 결론

구조적 프로그래밍: 제어흐름의 직접적인 전환(goto) 권한 x

객체지향 프로그래밍 : 제어흐름의 간접적인 전환(Pointer? ) 권한 x

함수형 프로그래밍 : 변수할당에 대한 권한x





---

# 토의



## 불변성과 관련해서

명구님 : class에서 final붙이기, 생성자도 팩토리 패턴 놓치게 되는 것



### parameter에 final붙이기 의견

시안님: 좋다고 생각함. final을 붙이면 명시적으로 보장되지 않나?

명구님 : dto를 final로 막지 않고 열어놨으면 임의로 바꾸면 찾아야함.



## 이벤트소싱

세원 : 불변성을 활용하는 요소로서 이벤트소싱 상태값이 아니라 트랜잭션을 사건들을 기록 변경, 삭제하지도 않기 때문에 동시성문제에서 자유로워지기 때문에 이점이 존재함. 

명구님: 분산시스템에서 트랜잭션롤백개념 









