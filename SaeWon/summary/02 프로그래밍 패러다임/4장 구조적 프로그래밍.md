# 4장. 구조적 프로그래밍

## 증명

유클리드 계층구조

증명을 위해서 모듈을 세분화할 필요가 존재 

→ goto문이 방해됨

→ 오로지 도움이 되는 goto사용방법론은 분기, 반복 에만 존재함. 

→ 이것이 순차실행(goto와 반대)과 만났을때 특별해짐

순차구문, 분기, 반복문이 올바름을 입증할 수 있게됨.

순차구문, 분기 → 열거법으로

반복문 → 귀납법으로

*열거법: 모든 경우의 수 나열

*귀납법: 일반적인 규칙에서 시작해 개별사례를 이용해 추론(기본규칙, k일때, k+1일때)

## 기능적 분해

위 과정을 통해 재귀적으로 기능을 세부적으로 나눌 수 있게 됨.

세부적으로 나눈 기능은 입증할수있는 단위가 됨.

대규모 시스템을 모듈과 컴포넌트로 나눌 수 있었다.

(모듈과 컴포넌트의 차이가?)

## 엄밀한 증명은 없었다

유클리드 계층구조를 만드는데 실패함

## 과학이 구출하다

수학은 참임을 증명하는것

과학은 거짓임을 증명하는것

## 테스트

테스트는 수학적 과정이 아닌 과학적 과정으로 이루어짐

구조적 프로그래밍은 증명가능한 세부집합으로 분해하고 기능이 거짓인지를 증명함.

이런 말로 요약될듯? 

“프로그래밍에 정답은 없지만 오답은 있다”

## 결론

‘반증가능한 단위’

앞으로: 제한적인 규칙들을 살펴볼것임.

---

## 알게된 점

goto문이 단순히 순서를 뒤죽박죽해서 유지보수를 어렵게 만들기 때문에 goto문을 피하라고 알고있었음.

하지만 더 중요한 것은 goto를 사용하지 않고 순차적실행하도록 하는것이 모듈을 ‘입증가능하도록 작은단위로 쪼개는데’ 도움이 된다는것을 알게됨.

내가볼때는 컴포넌트가 하자가 없음을 검증하는것에서 순차실행이 보장되지 않으면, 순서에 따라 각 컴포넌트의 기능이 의도와 다르게 달라질 수 있기 때문에 goto로 마구 점프하는것을 지양했던 것 아닐까

 

goto 왜 해로울까

setter쓰지말라는것 알고있음. 변경이 되면 추적이 어려움. 

break 보다는 return사용. 

증명: goto점프 체계화 구조화가 달라짐.





---

# 토의

## 1. goto가 구체적으로 왜 위험한걸까?

- 세원: goto문이 순서가 뒤죽박죽이 되어서 유지보수가 어렵다는 다소 추상적인 관점에서 접근해 왔었는데, 책을 통해 구조적프로그래밍이 함수를 검증가능한 단위로 쪼개서 소프트웨어의 품질을 검증하고자 하는데 방해가 되기 때문인 것으로 알게되었음. 그 이유에 대해서는 자세히 안나와 있는데, 순서가 보장되지 않으면, 함수가 적시에 사용된다는 보장이 되지 않기 때문에, 함수의 기능이 정상적이라 하더라도 의도된 대로 동작하지 않을 수 있기 때문이지 않을까 추정했음.
- 명구님: setter사용을 권장하지 않는 것과 마찬가지로 goto는 어떻게 진행되는지 추적하기가 어려운 구조가 되기 때문임. 이러한 차원에서 break보다 return으로 반복문을 빠져나오는것도 하나의 이유로 생각됨. 



