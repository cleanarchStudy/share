# 15장. 아키텍처



## 서론



프로그래밍과 계속적으로 연관이 됨. 



''많은 선택지를 오래 남겨두는 전략을 따라야한다." -> 변화에 유기적으로 대응하도록 만들어야 한다.



아키텍트 -> 동작여부와 관련 x 진행하지만, 본질적인것은 아니다. 



아키텍트의 목적: 시스템의 생명주기를 지원하는 것 

쉽게 개발, 유지보수, 배포



## 개발



팀의 형태나 규모에 따라서, 아키텍처의 형태가 달라질 수 있음.

ex)

1. 개발자 5명정도인 경우 -> Monolithic -> 팀별 단일 컴포넌트 아키텍처(상위 구조에 의해 방해받을 수 있음)

2. 7명식 5팀으로 나누어진 경우 -> 컴포넌트단위로 분리가 필요해짐

팀이 여럿인 경우가 되어서야 느낄 수 있음. 





## 배포

한번에 쉽게 배포할 수 있는 구조가 좋은 구조임.



ex)

개발 초기단계에 MSA를 도입하는 경우 너무 많은 컴포넌트를 배포해야 하므로 배포가 어려워짐.

-> 오히려 프로세스단위 + 서비스의 혼합구조로 융합하고 통합된 도구를 사용하여 연결하는 것이 나음.





## 운영

아키텍처가 미치는 영향 적음.

개발, 배포, 유지보수쪽이 좀더 비중이 큼.

운영에 필요한 

시스템 아키텍처는 유스케이스, 기능, 시스템의 필수 행위를 일급 엔티티로 격상시킴. -> 주요 목표로 인식되도록

시스템을 이해하기 쉬워짐



## 유지보수

시스템을 컴포넌트로 분리, 안정된 인터페이스로 격리 -> 미래에 추가될 길과 장애가 발생할 위협을 줄임. 



## 선택사항 열어두기

부드럽게 만들기

중요하지 않은 세부사항 



구성요소:

1. 정책(비즈니스로직)
2. 세부사항(외부, 사람, 프로그래머가 정책과 소통하기 위한 요소, 정책에 영향을 미치지 않음.)



세부사항에 대해 열어두어야함. 

ex)

1. db를 초기에 결정하는것인지,
2. 웹서버는 뭘로 할 것인지,
3. Rest를 적용할 것인지, 
4. 의존성 주입 프레임워크를 적용할 필요 x -> ???



## 장치독립성

입출력장치 -> 소프트웨어 함수로 추상화 



## 광고우편 

라인프린터 -> 자기테이프



![image-20230622180052802](./image/15%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5/image-20230622180052802.png)

입출력추상화로 간단하게 변경



## 물리적 주소할당

선형배열로 





-----

일급엔티티



### 실제로 고수준부터 먼저 구현하는지?

db먼저 구현

Controller먼저 구현

mock 





