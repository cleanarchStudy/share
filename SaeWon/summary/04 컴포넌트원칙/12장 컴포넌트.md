# 12장. 컴포넌트

## 서론

컴포넌트?

- **배포**할수 있는 가장 작은 단위(jar, dll, gem, exe)
- 잘 설계된 컴포넌트는 **독립적** -> 아마 멀티모듈의 경우 common을 지양하는 경우겠지?



## 컴포넌트의 간략한 역사

소프트웨어 초창기: 프로그램을 로드할 메모리주소를 수동으로 지정(ex *200)

라이브러리를 사용하기 위해서 애플리케이션코드에 합쳐서 컴파일. but 라이브러리는 소스코드로 유지, 소스코드 상태를 전부 로드하는건 당시 메모리로 힘듬

-> 해결책 : 각각을 개별적으로 컴파일하고 메모리 위치를 지정

-> 문제발생 : 어플리케이션이 커지면 라이브러리 메모리를 침범하게되어, 어플리케이션을 다시 세그먼트로 쪼개서 함수라이브러리 뒷편에 배치

-> 문제발생 : 함수라이브러리도 커지게 되면서 분리되어 저장된 메모리 침범

-> 계속 무한반복 





## 재배치성



위와 같은 침범에 따라 발생하는 방법의 한계로, 재배치 가능한 바이너리를 만드는것이었음.

-> 지능적인 로더는 1. 재배치할 메모리위치, 2. 재배치를 알릴 플래그(주로 참조하고있는 라이브러리의 메모리시작주소인경우 플래그 변경)

이를 통해 동적으로 바이너리를 재배치

어플리케이션은 외부참조, 라이브러리는 외부정의를 만들고 메타데이터에서 라이브러리함수의 위치를 가리킴으로 서로 링크시킴

-> 이게 링킹 로더



## 링커

링킹로더는 여러 바이너리를 순차적으로 재배치하느라 라이브러리를 많이 사용하도록 프로그램이 거대화하면서, 다시 병목현상이 생김.

-> 링킹로더에서 빠른 로더와 느린 링크부분을 분리해 프로그래머가 링크부분을 어플리케이션인 링커로 만들어 최적화

-> 하지만 지속적인 어플리케이션의 확장으로 이마저도 병목현상이 발생

-> 하드웨어의 비약적인 발전으로 한시간이상 걸리던 실행과정이 줄어듬

-> 링크와 로드를 동시에 할수도 있게 되어 훨씬 빨라짐

-> 동적으로 추가만 하는것으로 연결이 됨 -> 컴포넌트 플러그인 아키텍처



## 결론

런타임에 플러그인 형태로 결합할 수 있는 동적 링크파일 -> 소프트웨어 컴포넌트



## 알게된 점

JVM의 클래스로더가 로딩, 링크, 초기화로 나누어지는것을 매번 잊어먹다가

이해의 맥락으로 볼수있게됨.



JVM 클래스로더

1. 로딩

   1. .class 파일을 바이너리데이터로 '메소드' 영역에 저장
   2. 로딩완료후 메타데이터를 Metaspace영역에 저장(이 메타데이터가 바로 Class객체)

2. 링크

   1. Verification : .class 유효성검사
   2. Preparation : static 변수생성(상수풀에서 기본값으로 세팅)
   3. Resolution : 심볼릭 메모리 레퍼런스를 실제 메모리영역의 레퍼런스로 교체

3. 초기화

   1. 클래스, 인터페이스의 초기화
   1. static블록의 실행도 이때 발생
   
   클래스로더 관련 참고 링크: https://blog.hexabrain.net/397



클래스로더는

Bootstrap ClassLoader

Platform ClassLoader(8까지는 Extension ClassLoader)

Application ClassLoader 

3가지

클래스 로딩은 상향식으로 위임해서 찾아냄. 



*gradle이나 maven같은 빌드툴에 의해 생기는 의존라이브러리는 Application ClassLoader에 의해 검색됨.

-----



컴포넌트 배포단위

MSA위주로 생각했음. 



## 컴포넌트 의미가 다양함. 



명구님 : 컴포넌트: 패키지, 모듈 객체 등 다양한 수준에서 해석할 수 있음. 

클래스로도 간단하게 구현할수있다 생각. 



잘 설계된 클래스면 독립적으로 배포가 가능해야한다. 



